/*
** ###################################################################
**     This code is generated by the Device Initialization Tool.
**     It is overwritten during code generation.
**     USER MODIFICATION ARE PRESERVED ONLY INSIDE INTERRUPT SERVICE ROUTINES
**     OR EXPLICITLY MARKED SECTIONS
**
**     Project     : DeviceInitialization
**     Processor   : MCF51MM256VLK
**     Version     : Component 01.003, Driver 01.08, CPU db: 3.00.020
**     Datasheet   : MCF51MM256RM Rev. 3
**     Date/Time   : 2013-10-01, 12:39, # CodeGen: 47
**     Abstract    :
**         This module contains device initialization code 
**         for selected on-chip peripherals.
**     Contents    :
**         Function "MCU_init" initializes selected peripherals
**
**     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################
*/

/* MODULE MCUinit */

#include <mcf51mm256.h>                /* I/O map for MCF51MM256VLK */
#include "MCUinit.h"

/* Standard ANSI C types */
#ifndef int8_t
typedef signed char int8_t;
#endif
#ifndef int16_t
typedef signed short int int16_t;
#endif
#ifndef int32_t
typedef signed long int int32_t;
#endif

#ifndef uint8_t
typedef unsigned char uint8_t;
#endif
#ifndef uint16_t
typedef unsigned short int uint16_t;
#endif
#ifndef uint32_t
typedef unsigned long int uint32_t;
#endif

/* pragma to disable "possibly unassigned ISR handler" message generated by compiler on definition of ISR without vector number */
#pragma warn_absolute off

/* User declarations and definitions */
#include "define.h"
#include "types.h"
#include "externa.h"
#include "aplicacao.h"
uint32 contador_TPM1 = 0;
uint32 contador_TPM2 = 0; 
uint32 contador = 0;
uint16 x = 0;		
uint16 i = 0; 
uint16 resultado;
uint16 read_adc;
uint8 channel;
uint8 ciclo = 1;
uint32 contador_CH = 0; 
uint32 contador_LCD = 0; 
uint32 contador_motor = 0;
uint32 contador_repouso = 0;
//extern uint16 t_on;
//extern uint16 t_off;
//extern unsigned long int number;
//extern uint16 t_vcc;
extern uint8 motor_on;
/*   Code, declarations and definitions here will be preserved during code generation */
/* End of user declarations and definitions */

/*
** ===================================================================
**     Method      :  __initialize_hardware (component MCF51MM256_80)
**
**     Description :
**         Initialization code for CPU core and a clock source.
** ===================================================================
*/
void __initialize_hardware(void)
{
  /* ### MCF51MM256_80 "Cpu" init code ... */
  /*  PE initialization code after reset */
  /* Common initialization of the write once registers */
  /* SOPT1: COPT=0,STOPE=0,WAITE=1,BLMSS=0,MBSL=0,BKGDPE=1,RSTPE=1 */
  SOPT1 = 0x13U;                                   
  /* SPMSC1: LVDF=0,LVDACK=0,LVDIE=0,LVDRE=1,LVDSE=1,LVDE=1,BGBE=0 */
  SPMSC1 = 0x1CU;                                   
  /* SPMSC2: LPR=0,LPRS=0,LPWUI=0,PPDF=0,PPDACK=0,PPDE=1,PPDC=0 */
  SPMSC2 = 0x02U;                                   
  /* SPMSC3: LVDV=0,LVWV=0,LVWIE=0 */
  SPMSC3 &= (unsigned char)~(unsigned char)0x38U;                     
  /* Initialization of CPU registers */
  /*lint -save  -e950 Disable MISRA rule (1.1) checking. */
  asm {
    /* VBR: ADDRESS=0 */
    clr.l d0
    movec d0,VBR
    /* CPUCR: ARD=0,IRD=0,IAE=0,IME=0,BWD=0,FSD=0 */
    clr.l d0
    movec d0,CPUCR
  }
  /*lint -restore Enable MISRA rule (1.1) checking. */
  /*  System clock initialization */
  /*lint -save  -e923 Disable MISRA rule (11.3) checking. */
  if (*(unsigned char*far)0x03FFU != 0xFFU) { /* Test if the device trim value is stored on the specified address */
    MCGTRM = *(unsigned char*far)0x03FFU; /* Initialize MCGTRM register from a non volatile memory */
    MCGSC = *(unsigned char*far)0x03FEU; /* Initialize MCGSC register from a non volatile memory */
  }
  /*lint -restore Enable MISRA rule (11.3) checking. */
  /* CCSCTRL: RANGE1=0,HGO1=0,ERCLKEN1=0,OSCINIT1=0,EREFS1=1,EN=0,TEST=0,SEL=0 */
  CCSCTRL = 0x08U;                     /* Configure the XOSC1 clock */
  /* MCGC2: BDIV=0,RANGE=1,HGO=1,LP=0,EREFS=1,ERCLKEN=1,EREFSTEN=0 */
  MCGC2 = 0x36U;                       /* Set MCGC2 register */
  while(MCGSC_OSCINIT == 0U) {         /* Wait until external reference is stable */
  }
  /* MCGC3: DIV32=1 */
  MCGC3 |= (unsigned char)0x10U;                      
  /* MCGC1: CLKS=0,RDIV=4,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
  MCGC1 = 0x22U;                       /* Set MCGC1 register */
  while(MCGSC_IREFST != 0U) {          /* Wait until external reference is selected */
  }
  /* MCGC3: LOLIE=0,PLLS=0,CME=0,DIV32=1,VDIV=1 */
  MCGC3 = 0x11U;                       /* Set MCGC3 register */
  /* MCGC4: DMX32=0,DRST_DRS=2 */
  MCGC4 = 0x02U;                       /* Set MCGC4 register */
  while(MCGSC_LOCK == 0U) {            /* Wait until FLL is locked */
  }
  while((MCGSC & 0x0CU) != 0x00U) {    /* Wait until FLL clock is selected as a bus clock reference */
  }
  
  /* SOPT2: COPCLKS=0,COPW=0,USB_BIGEND=1,CLKOUT_EN=0,CMT_CLK_SEL=0,ACIC=0 */
  SOPT2 = 0x20U;                                   
  /* Initialization of the ExternalBus module */
  /* MBCSMR0: V=0 */
  MBCSMR0 &= (unsigned long int)~0xFEFFUL;             
  /* MBCSMR1: V=0 */
  MBCSMR1 &= (unsigned long int)~0xFEFFUL;             

  /* INTC_WCR: ENB=1,MASK=0 */
  INTC_WCR = 0x80U;                                   
}

/*
** ===================================================================
**     Method      :  MCU_init (component MCF51MM256_80)
**
**     Description :
**         Device initialization code for selected peripherals.
** ===================================================================
*/
void MCU_init(void)
{
  /* SCGC1: CMT=1,TPM2=1,TPM1=1,ADC=1,DAC=1,IIC=1,SCI2=1,SCI1=1 */
  SCGC1 = 0xFFU;                                   
  /* SCGC2: USB=1,PDB=1,IRQ=1,KBI=1,PRACMP=1,MFB=1,SPI2=1,SPI1=1 */
  SCGC2 = 0xFFU;                                   
  /* SCGC3: VREF=1,CRC=1,FLS2=1,FLS1=1,TRIAMP2=1,TRIAMP1=1,GPOA2=1,GPOA1=1 */
  SCGC3 = 0xFFU;                                   
  /* Common initialization of the CPU registers */
  /* PTASE: PTASE7=0,PTASE6=0,PTASE5=0,PTASE4=0,PTASE3=0,PTASE2=0,PTASE1=0,PTASE0=0 */
  PTASE = 0x00U;                                   
  /* PTBSE: PTBSE7=0,PTBSE6=0,PTBSE5=0,PTBSE4=0,PTBSE3=0,PTBSE2=0,PTBSE1=0,PTBSE0=0 */
  PTBSE = 0x00U;                                   
  /* PTCSE: PTCSE7=0,PTCSE6=0,PTCSE5=0,PTCSE4=0,PTCSE3=0,PTCSE2=0,PTCSE1=0,PTCSE0=0 */
  PTCSE = 0x00U;                                   
  /* PTDSE: PTDSE7=0,PTDSE6=0,PTDSE5=0,PTDSE4=0,PTDSE3=0,PTDSE2=0,PTDSE1=0,PTDSE0=0 */
  PTDSE = 0x00U;                                   
  /* PTESE: PTESE7=0,PTESE6=0,PTESE5=0,PTESE3=0,PTESE2=0,PTESE1=0,PTESE0=0 */
  PTESE &= (unsigned char)~(unsigned char)0xEFU;                     
  /* PTFSE: PTFSE7=0,PTFSE6=0,PTFSE5=0,PTFSE4=0,PTFSE3=0,PTFSE2=0,PTFSE1=0,PTFSE0=0 */
  PTFSE = 0x00U;                                   
  /* PTGSE: PTGSE0=0 */
  PTGSE &= (unsigned char)~(unsigned char)0x01U;                     
  /* PTADS: PTADS7=0,PTADS6=0,PTADS5=0,PTADS4=0,PTADS3=0,PTADS2=0,PTADS1=0,PTADS0=0 */
  PTADS = 0x00U;                                   
  /* PTBDS: PTBDS7=0,PTBDS6=0,PTBDS5=0,PTBDS4=0,PTBDS3=0,PTBDS2=0,PTBDS1=0,PTBDS0=0 */
  PTBDS = 0x00U;                                   
  /* PTCDS: PTCDS7=0,PTCDS6=0,PTCDS5=0,PTCDS4=0,PTCDS3=0,PTCDS2=0,PTCDS1=0,PTCDS0=0 */
  PTCDS = 0x00U;                                   
  /* PTDDS: PTDDS7=0,PTDDS6=0,PTDDS5=0,PTDDS4=0,PTDDS3=0,PTDDS2=0,PTDDS1=0,PTDDS0=0 */
  PTDDS = 0x00U;                                   
  /* PTEDS: PTEDS7=0,PTEDS6=0,PTEDS5=0,PTEDS4=0,PTEDS3=0,PTEDS2=0,PTEDS1=0,PTEDS0=0 */
  PTEDS = 0x00U;                                   
  /* PTFDS: PTFDS7=0,PTFDS6=0,PTFDS5=0,PTFDS4=0,PTFDS3=0,PTFDS2=0,PTFDS1=0,PTFDS0=0 */
  PTFDS = 0x00U;                                   
  /* PTGDS: PTGDS7=0,PTGDS6=0,PTGDS5=0,PTGDS4=0,PTGDS3=0,PTGDS2=0,PTGDS1=0,PTGDS0=0 */
  PTGDS = 0x00U;                                   
  /* PTAIFE: PTAIFE7=1,PTAIFE6=1,PTAIFE5=1,PTAIFE4=1,PTAIFE3=1,PTAIFE2=1,PTAIFE1=1,PTAIFE0=1 */
  PTAIFE = 0xFFU;                                   
  /* PTBIFE: PTBIFE7=1,PTBIFE6=1,PTBIFE5=1,PTBIFE4=1,PTBIFE3=1,PTBIFE2=1,PTBIFE0=1 */
  PTBIFE |= (unsigned char)0xFDU;                      
  /* PTCIFE: PTCIFE7=1,PTCIFE6=1,PTCIFE5=1,PTCIFE4=1,PTCIFE3=1,PTCIFE2=1,PTCIFE1=1,PTCIFE0=1 */
  PTCIFE = 0xFFU;                                   
  /* PTDIFE: PTDIFE7=1,PTDIFE6=1,PTDIFE5=1,PTDIFE4=1,PTDIFE3=1,PTDIFE2=1,PTDIFE1=1 */
  PTDIFE |= (unsigned char)0xFEU;                      
  /* PTEIFE: PTEIFE7=1,PTEIFE6=1,PTEIFE5=1,PTEIFE4=1,PTEIFE3=1,PTEIFE2=1,PTEIFE1=1,PTEIFE0=1 */
  PTEIFE = 0xFFU;                                   
  /* PTFIFE: PTFIFE7=1,PTFIFE6=1,PTFIFE5=1,PTFIFE4=1,PTFIFE3=1,PTFIFE2=1,PTFIFE1=1,PTFIFE0=1 */
  PTFIFE = 0xFFU;                                   
  /* PTGIFE: PTGIFE0=1 */
  PTGIFE |= (unsigned char)0x01U;                      
  /* SIMCO: CS=0 */
  SIMCO &= (unsigned char)~(unsigned char)0x07U;                     
  /* ### Init_TPM init code */
  /* TPM2SC: TOF=0,TOIE=0,CPWMS=0,CLKSB=0,CLKSA=0,PS2=0,PS1=0,PS0=0 */
  TPM2SC = 0x00U;                      /* Stop and reset counter */
  TPM2MOD = 0x2FU;                     /* Period value setting */
  (void)(TPM2SC == 0U);                /* Overflow int. flag clearing (first part) */
  /* TPM2SC: TOF=0,TOIE=1,CPWMS=0,CLKSB=0,CLKSA=1,PS2=0,PS1=0,PS0=0 */
  TPM2SC = 0x48U;                      /* Int. flag clearing (2nd part) and timer control register setting */
  /* ### Init_ADC init code */
  /* SIMIPS: ADCTRS=0 */
  SIMIPS &= (unsigned char)~(unsigned char)0x80U; /* Selects the PDB as the source of internal HW trigger */
  /* APCTL1: ADPC7=0,ADPC6=0,ADPC5=0,ADPC4=0,ADPC3=0,ADPC2=0,ADPC1=0,ADPC0=0 */
  APCTL1 = 0x00U;                                   
  /* ADCCFG1: ADLPC=0,ADIV1=1,ADIV0=0,ADLSMP=0,MODE1=0,MODE0=1,ADICLK1=0,ADICLK0=0 */
  ADCCFG1 = 0x44U;                                   
  /* ADCCFG2: ADACKEN=0,ADHSC=0,ADLSTS1=0,ADLSTS0=0 */
  ADCCFG2 = 0x00U;                                   
  /* ADCCV1: CV115=0,CV114=0,CV113=0,CV112=0,CV111=0,CV110=0,CV19=0,CV18=0,CV17=0,CV16=0,CV15=0,CV14=0,CV13=0,CV12=0,CV11=0,CV10=0 */
  ADCCV1 = 0x00U;                            
  /* ADCCV2: CV215=0,CV214=0,CV213=0,CV212=0,CV211=0,CV210=0,CV29=0,CV28=0,CV27=0,CV26=0,CV25=0,CV24=0,CV23=0,CV22=0,CV21=0,CV20=0 */
  ADCCV2 = 0x00U;                            
  /* ADCSC2: ADACT=0,ADTRG=0,ACFE=0,ACFGT=0,ACREN=0,REFSEL1=0,REFSEL0=0 */
  ADCSC2 = 0x00U;                                   
  /* ADCSC3: CAL=0,CALF=0,ADCO=0,AVGE=1,AVGS1=1,AVGS0=1 */
  ADCSC3 = 0x07U;                                   
  /* ADCSC1A: COCOA=0,AIENA=1,DIFFA=0,ADCHA4=0,ADCHA3=0,ADCHA2=1,ADCHA1=1,ADCHA0=0 */
  ADCSC1A = 0x46U;                                   
  /* ADCSC1B: COCOB=0,AIENB=0,DIFFB=0,ADCHB4=1,ADCHB3=1,ADCHB2=1,ADCHB1=1,ADCHB0=1 */
  ADCSC1B = 0x1FU;                                   
  /* ADCSC1C: COCOC=0,AIENC=0,DIFFC=0,ADCHC4=1,ADCHC3=1,ADCHC2=1,ADCHC1=1,ADCHC0=1 */
  ADCSC1C = 0x1FU;                                   
  /* ADCSC1D: COCOD=0,AIEND=0,DIFFD=0,ADCHD4=1,ADCHD3=1,ADCHD2=1,ADCHD1=1,ADCHD0=1 */
  ADCSC1D = 0x1FU;                                   
  /* ADCSC1E: COCOE=0,AIENE=0,DIFFE=0,ADCHE4=1,ADCHE3=1,ADCHE2=1,ADCHE1=1,ADCHE0=1 */
  ADCSC1E = 0x1FU;                                   
  /* ADCSC1F: COCOF=0,AIENF=0,DIFFF=0,ADCHF4=1,ADCHF3=1,ADCHF2=1,ADCHF1=1,ADCHF0=1 */
  ADCSC1F = 0x1FU;                                   
  /* ADCSC1G: COCOG=0,AIENG=0,DIFFG=0,ADCHG4=1,ADCHG3=1,ADCHG2=1,ADCHG1=1,ADCHG0=1 */
  ADCSC1G = 0x1FU;                                   
  /* ADCSC1H: COCOH=0,AIENH=0,DIFFH=0,ADCHH4=1,ADCHH3=1,ADCHH2=1,ADCHH1=1,ADCHH0=1 */
  ADCSC1H = 0x1FU;                                   
  /* ### Init_TPM init code */
  /* TPM1SC: TOF=0,TOIE=0,CPWMS=0,CLKSB=0,CLKSA=0,PS2=0,PS1=0,PS0=0 */
  TPM1SC = 0x00U;                      /* Stop and reset counter */
  TPM1MOD = 0x2FU;                     /* Period value setting */
  (void)(TPM1SC == 0U);                /* Overflow int. flag clearing (first part) */
  /* TPM1SC: TOF=0,TOIE=1,CPWMS=0,CLKSB=0,CLKSA=1,PS2=0,PS1=0,PS0=0 */
  TPM1SC = 0x48U;                      /* Int. flag clearing (2nd part) and timer control register setting */
  /* ### Init_GPIO init code */
  /* PTAD: PTAD6=0,PTAD5=0,PTAD4=0 */
  PTAD &= (unsigned char)~(unsigned char)0x70U;                     
  /* PTAPE: PTAPE6=1 */
  PTAPE |= (unsigned char)0x40U;                      
  /* PTADD: PTADD6=0,PTADD5=1,PTADD4=1 */
  PTADD = (unsigned char)((PTADD & (unsigned char)~0x40U) | (unsigned char)0x30U);
  /* ### Init_GPIO init code */
  /* PTDD: PTDD7=0,PTDD6=0,PTDD2=0 */
  PTDD &= (unsigned char)~(unsigned char)0xC4U;                     
  /* PTDPE: PTDPE2=1 */
  PTDPE |= (unsigned char)0x04U;                      
  /* PTDDD: PTDDD7=1,PTDDD6=1,PTDDD2=0 */
  PTDDD = (unsigned char)((PTDDD & (unsigned char)~0x04U) | (unsigned char)0xC0U);
  /* ### Init_GPIO init code */
  /* PTCD: PTCD7=0,PTCD6=0,PTCD5=0,PTCD4=0,PTCD3=0,PTCD1=0,PTCD0=0 */
  PTCD &= (unsigned char)~(unsigned char)0xFBU;                     
  /* PTCPE: PTCPE7=1,PTCPE6=1,PTCPE5=1 */
  PTCPE |= (unsigned char)0xE0U;                      
  /* PTCDD: PTCDD7=0,PTCDD6=0,PTCDD5=0,PTCDD4=1,PTCDD3=1,PTCDD1=1,PTCDD0=1 */
  PTCDD = (unsigned char)((PTCDD & (unsigned char)~0xE0U) | (unsigned char)0x1BU);
  /* ### Init_GPIO init code */
  /* PTBD: PTBD7=0 */
  PTBD &= (unsigned char)~(unsigned char)0x80U;                     
  /* PTBDD: PTBDD7=1 */
  PTBDD |= (unsigned char)0x80U;                      
  /* ### */
  /*lint -save  -e950 Disable MISRA rule (1.1) checking. */
  asm {                                /* Set Interrupt level 0 */
    move.w SR,D0;
    andi.l #0xF8FF,D0;
    move.w D0,SR;
  };
  /*lint -restore Enable MISRA rule (1.1) checking. */

} /*MCU_init*/


/*lint -save  -e765 Disable MISRA rule (8.10) checking. */
/*
** ===================================================================
**     Interrupt handler : isr_default
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isr_default(void)
{
  /* Write your interrupt code here ... */

}
/* end of isr_default */


/*
** ===================================================================
**     Interrupt handler : isrVlvd
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVlvd(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVlvd */


/*
** ===================================================================
**     Interrupt handler : isrVadc
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVadc(void)
{
  /* Write your interrupt code here ... */
	while(ADCSC1A_COCOA != 1){}
	read_adc = ADCRA;
	/*if(channel == 0x06)
	{
		read_adc = resultado;
	}
	*/
}
/* end of isrVadc */


/*
** ===================================================================
**     Interrupt handler : isrVtpm1ovf
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVtpm1ovf(void)
{
  /* Write your interrupt code here ... */
	TPM1SC;
	TPM1SC_TOF = 0;
	//inicia a contagem
	if(Flag_Start_TPM1 == TRUE)
	{
		contador_TPM1++;
		if(contador_TPM1 >= timer)
		{
			contador_TPM1      = FALSE;
			Flag_Overflow_TPM1 = TRUE;
			Flag_Start_TPM1    = FALSE;
		}
	}
	
}
/* end of isrVtpm1ovf */


/*
** ===================================================================
**     Interrupt handler : isrVtpm2ovf
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVtpm2ovf(void)
{
  /* Write your interrupt code here ... */
  /* Write your interrupt code here ... */
	TPM2SC;
	TPM2SC_TOF = 0;
	//contador da rotina da função delay
	contador_TPM2++;
	if(contador_TPM2 >= number)
	{
		contador_TPM2      = FALSE;
		Flag_Overflow_TPM2 = TRUE;
	}
	//rotina que verifica de as chaves foram precionda
	read_ch();
	//contador da rotina que faz o debounce das chaves
	if(Flag_Start_Contador_CH == TRUE)
	{
		contador_CH++;
		if(contador_CH >= 50000)//100 mile segundos
		{
			Flag_Start_Contador_CH = FALSE;
			contador_CH = FALSE;
			Flag_Overflow_CH = TRUE;
		}
	}
	//Contador da rotina de controle LCD
	if(Flag_Start_Contador_LCD == TRUE)
	{
		contador_LCD++;
		if(contador_LCD >= 1000000)//50000000)// 10 segundos
		{
			Flag_Overflow_LCD 		= TRUE;
			Flag_Start_Contador_LCD = FALSE;
			contador_LCD 			= 0;
		}
	}
	else if(Flag_Start_Contador_LCD |= TRUE)
	{
		contador_LCD = 0;
	}
	//controle do inversor
	// É necessario que essa rotina execute no tempo da interrupção
	if(Flag_Start_PWM == TRUE)
	{
		Controle_PWM(ON);
	}
	//Contador da rotina de partida do motor
	if(Flag_Start_Contador_Motor == TRUE)
	{
		contador_motor++;
		if(contador_motor >= 100)//valor a definir
		{
			contador_motor             = FALSE;
			Flag_Overflow_Motor        = TRUE;
			Flag_Start_Contador_Motor  = FALSE;
		}
	}
	// Contador da rotina de repouso do motor
	if(Flag_Start_Repouso == TRUE)
	{
		contador_repouso++;
		if(contador_repouso >= 100000) //100 segundos - 10000000
		{
			contador_repouso           =  FALSE;
			Flag_Start_Repouso         =  FALSE;
			Flag_Overflow_Repouso      =  TRUE;
		}
	}	
}
/* end of isrVtpm2ovf */


/*lint -restore Enable MISRA rule (8.10) checking. */

/*lint -save  -e950 Disable MISRA rule (1.1) checking. */
/* Initialization of the CPU registers in FLASH */
/* CHKSBYP1: BYPASS=0 */
static unsigned char CHKSBYP1_INIT @0x0000040A = 0x00U;
/* CHKSBYP2: BYPASS=0 */
static unsigned char CHKSBYP2_INIT @0x0002040A = 0x00U;
/* NV1PROT: FPS6=1,FPS5=1,FPS4=1,FPS3=1,FPS2=1,FPS1=1,FPS0=1,FPOPEN=1 */
static unsigned char NV1PROT_INIT @0x0000040D = 0xFFU;
/* NV2PROT: FPS6=1,FPS5=1,FPS4=1,FPS3=1,FPS2=1,FPS1=1,FPS0=1,FPOPEN=1 */
static unsigned char NV2PROT_INIT @0x0002040D = 0xFFU;
/* NV1OPT: KEYEN1=0,KEYEN0=1,SEC1=1,SEC0=1 */
static unsigned char NV1OPT_INIT @0x0000040F = 0x7FU;
/* NV2OPT: KEYEN1=0,KEYEN0=1,SEC1=1,SEC0=1 */
static unsigned char NV2OPT_INIT @0x0002040F = 0x7FU;
/*lint -restore Enable MISRA rule (1.1) checking. */



typedef unsigned long far TStackPntr;

#ifdef __cplusplus
extern "C" {
#endif
extern void _startup(void);
extern TStackPntr _SP_INIT[];

#ifdef __cplusplus
}
#endif

/* Interrupt vector table */
#ifndef UNASSIGNED_ISR
  #define UNASSIGNED_ISR isr_default   /* unassigned interrupt service routine */
#endif

/*lint -save  -e950 -e740 -e931 -e926 -e927 -e928 -e929 Disable MISRA rule (1.1,1.2,11.4) checking. */
                                                                /*Address    Lvl Pri */
void (*const vector_0)(void)   @INITSP       = (void(*const )(void))_SP_INIT; /*0x00000000 -   - */
void (*const vector_1)(void)   @INITPC       = _startup;        /*0x00000004 -   - */
void (*const vector_2)(void)   @Vaccerr      = UNASSIGNED_ISR;  /*0x00000008 -   - */
void (*const vector_3)(void)   @Vadderr      = UNASSIGNED_ISR;  /*0x0000000C -   - */
void (*const vector_4)(void)   @Viinstr      = UNASSIGNED_ISR;  /*0x00000010 -   - */
void (*const vector_5)(void)   @VReserved5   = UNASSIGNED_ISR;  /*0x00000014 -   - */
void (*const vector_6)(void)   @VReserved6   = UNASSIGNED_ISR;  /*0x00000018 -   - */
void (*const vector_7)(void)   @VReserved7   = UNASSIGNED_ISR;  /*0x0000001C -   - */
void (*const vector_8)(void)   @Vprviol      = UNASSIGNED_ISR;  /*0x00000020 -   - */
void (*const vector_9)(void)   @Vtrace       = UNASSIGNED_ISR;  /*0x00000024 -   - */
void (*const vector_10)(void)  @Vunilaop     = UNASSIGNED_ISR;  /*0x00000028 -   - */
void (*const vector_11)(void)  @Vunilfop     = UNASSIGNED_ISR;  /*0x0000002C -   - */
void (*const vector_12)(void)  @Vdbgi        = UNASSIGNED_ISR;  /*0x00000030 -   - */
void (*const vector_13)(void)  @VReserved13  = UNASSIGNED_ISR;  /*0x00000034 -   - */
void (*const vector_14)(void)  @Vferror      = UNASSIGNED_ISR;  /*0x00000038 -   - */
void (*const vector_15)(void)  @VReserved15  = UNASSIGNED_ISR;  /*0x0000003C -   - */
void (*const vector_16)(void)  @VReserved16  = UNASSIGNED_ISR;  /*0x00000040 -   - */
void (*const vector_17)(void)  @VReserved17  = UNASSIGNED_ISR;  /*0x00000044 -   - */
void (*const vector_18)(void)  @VReserved18  = UNASSIGNED_ISR;  /*0x00000048 -   - */
void (*const vector_19)(void)  @VReserved19  = UNASSIGNED_ISR;  /*0x0000004C -   - */
void (*const vector_20)(void)  @VReserved20  = UNASSIGNED_ISR;  /*0x00000050 -   - */
void (*const vector_21)(void)  @VReserved21  = UNASSIGNED_ISR;  /*0x00000054 -   - */
void (*const vector_22)(void)  @VReserved22  = UNASSIGNED_ISR;  /*0x00000058 -   - */
void (*const vector_23)(void)  @VReserved23  = UNASSIGNED_ISR;  /*0x0000005C -   - */
void (*const vector_24)(void)  @Vspuri       = UNASSIGNED_ISR;  /*0x00000060 -   - */
void (*const vector_25)(void)  @VReserved25  = UNASSIGNED_ISR;  /*0x00000064 -   - */
void (*const vector_26)(void)  @VReserved26  = UNASSIGNED_ISR;  /*0x00000068 -   - */
void (*const vector_27)(void)  @VReserved27  = UNASSIGNED_ISR;  /*0x0000006C -   - */
void (*const vector_28)(void)  @VReserved28  = UNASSIGNED_ISR;  /*0x00000070 -   - */
void (*const vector_29)(void)  @VReserved29  = UNASSIGNED_ISR;  /*0x00000074 -   - */
void (*const vector_30)(void)  @VReserved30  = UNASSIGNED_ISR;  /*0x00000078 -   - */
void (*const vector_31)(void)  @VReserved31  = UNASSIGNED_ISR;  /*0x0000007C -   - */
void (*const vector_32)(void)  @Vtrap0       = UNASSIGNED_ISR;  /*0x00000080 -   - */
void (*const vector_33)(void)  @Vtrap1       = UNASSIGNED_ISR;  /*0x00000084 -   - */
void (*const vector_34)(void)  @Vtrap2       = UNASSIGNED_ISR;  /*0x00000088 -   - */
void (*const vector_35)(void)  @Vtrap3       = UNASSIGNED_ISR;  /*0x0000008C -   - */
void (*const vector_36)(void)  @Vtrap4       = UNASSIGNED_ISR;  /*0x00000090 -   - */
void (*const vector_37)(void)  @Vtrap5       = UNASSIGNED_ISR;  /*0x00000094 -   - */
void (*const vector_38)(void)  @Vtrap6       = UNASSIGNED_ISR;  /*0x00000098 -   - */
void (*const vector_39)(void)  @Vtrap7       = UNASSIGNED_ISR;  /*0x0000009C -   - */
void (*const vector_40)(void)  @Vtrap8       = UNASSIGNED_ISR;  /*0x000000A0 -   - */
void (*const vector_41)(void)  @Vtrap9       = UNASSIGNED_ISR;  /*0x000000A4 -   - */
void (*const vector_42)(void)  @Vtrap10      = UNASSIGNED_ISR;  /*0x000000A8 -   - */
void (*const vector_43)(void)  @Vtrap11      = UNASSIGNED_ISR;  /*0x000000AC -   - */
void (*const vector_44)(void)  @Vtrap12      = UNASSIGNED_ISR;  /*0x000000B0 -   - */
void (*const vector_45)(void)  @Vtrap13      = UNASSIGNED_ISR;  /*0x000000B4 -   - */
void (*const vector_46)(void)  @Vtrap14      = UNASSIGNED_ISR;  /*0x000000B8 -   - */
void (*const vector_47)(void)  @Vtrap15      = UNASSIGNED_ISR;  /*0x000000BC -   - */
void (*const vector_48)(void)  @VReserved48  = UNASSIGNED_ISR;  /*0x000000C0 -   - */
void (*const vector_49)(void)  @VReserved49  = UNASSIGNED_ISR;  /*0x000000C4 -   - */
void (*const vector_50)(void)  @VReserved50  = UNASSIGNED_ISR;  /*0x000000C8 -   - */
void (*const vector_51)(void)  @VReserved51  = UNASSIGNED_ISR;  /*0x000000CC -   - */
void (*const vector_52)(void)  @VReserved52  = UNASSIGNED_ISR;  /*0x000000D0 -   - */
void (*const vector_53)(void)  @VReserved53  = UNASSIGNED_ISR;  /*0x000000D4 -   - */
void (*const vector_54)(void)  @VReserved54  = UNASSIGNED_ISR;  /*0x000000D8 -   - */
void (*const vector_55)(void)  @VReserved55  = UNASSIGNED_ISR;  /*0x000000DC -   - */
void (*const vector_56)(void)  @VReserved56  = UNASSIGNED_ISR;  /*0x000000E0 -   - */
void (*const vector_57)(void)  @VReserved57  = UNASSIGNED_ISR;  /*0x000000E4 -   - */
void (*const vector_58)(void)  @VReserved58  = UNASSIGNED_ISR;  /*0x000000E8 -   - */
void (*const vector_59)(void)  @VReserved59  = UNASSIGNED_ISR;  /*0x000000EC -   - */
void (*const vector_60)(void)  @VReserved60  = UNASSIGNED_ISR;  /*0x000000F0 -   - */
void (*const vector_61)(void)  @Vunsinstr    = UNASSIGNED_ISR;  /*0x000000F4 -   - */
void (*const vector_62)(void)  @VReserved62  = UNASSIGNED_ISR;  /*0x000000F8 -   - */
void (*const vector_63)(void)  @VReserved63  = UNASSIGNED_ISR;  /*0x000000FC -   - */
void (*const vector_64)(void)  @Virq         = UNASSIGNED_ISR;  /*0x00000100 -   - */
void (*const vector_65)(void)  @Vlvd         = isrVlvd;         /*0x00000104 7   3 */
void (*const vector_66)(void)  @Vlol         = UNASSIGNED_ISR;  /*0x00000108 -   - */
void (*const vector_67)(void)  @VReserved67  = UNASSIGNED_ISR;  /*0x0000010C -   - */
void (*const vector_68)(void)  @Vpdb         = UNASSIGNED_ISR;  /*0x00000110 -   - */
void (*const vector_69)(void)  @Vdac         = UNASSIGNED_ISR;  /*0x00000114 -   - */
void (*const vector_70)(void)  @Vspi1        = UNASSIGNED_ISR;  /*0x00000118 -   - */
void (*const vector_71)(void)  @Vadc         = isrVadc;         /*0x0000011C 6   2 */
void (*const vector_72)(void)  @Vusb         = UNASSIGNED_ISR;  /*0x00000120 -   - */
void (*const vector_73)(void)  @Vtpm1ch0     = UNASSIGNED_ISR;  /*0x00000124 -   - */
void (*const vector_74)(void)  @Vtpm1ch1     = UNASSIGNED_ISR;  /*0x00000128 -   - */
void (*const vector_75)(void)  @Vtpm1ch2     = UNASSIGNED_ISR;  /*0x0000012C -   - */
void (*const vector_76)(void)  @Vtpm1ch3     = UNASSIGNED_ISR;  /*0x00000130 -   - */
void (*const vector_77)(void)  @Vtpm1ovf     = isrVtpm1ovf;     /*0x00000134 5   3 */
void (*const vector_78)(void)  @Vspi2        = UNASSIGNED_ISR;  /*0x00000138 -   - */
void (*const vector_79)(void)  @Vcmt         = UNASSIGNED_ISR;  /*0x0000013C -   - */
void (*const vector_80)(void)  @Vtpm2ch0     = UNASSIGNED_ISR;  /*0x00000140 -   - */
void (*const vector_81)(void)  @Vtpm2ch1     = UNASSIGNED_ISR;  /*0x00000144 -   - */
void (*const vector_82)(void)  @Vtpm2ch2     = UNASSIGNED_ISR;  /*0x00000148 -   - */
void (*const vector_83)(void)  @Vtpm2ch3     = UNASSIGNED_ISR;  /*0x0000014C -   - */
void (*const vector_84)(void)  @Vtpm2ovf     = isrVtpm2ovf;     /*0x00000150 4   3 */
void (*const vector_85)(void)  @Viic         = UNASSIGNED_ISR;  /*0x00000154 -   - */
void (*const vector_86)(void)  @Vpracmp      = UNASSIGNED_ISR;  /*0x00000158 -   - */
void (*const vector_87)(void)  @Vsci1err     = UNASSIGNED_ISR;  /*0x0000015C -   - */
void (*const vector_88)(void)  @Vsci1rx      = UNASSIGNED_ISR;  /*0x00000160 -   - */
void (*const vector_89)(void)  @Vsci1tx      = UNASSIGNED_ISR;  /*0x00000164 -   - */
void (*const vector_90)(void)  @Vsci2err     = UNASSIGNED_ISR;  /*0x00000168 -   - */
void (*const vector_91)(void)  @Vsci2rx      = UNASSIGNED_ISR;  /*0x0000016C -   - */
void (*const vector_92)(void)  @Vsci2tx      = UNASSIGNED_ISR;  /*0x00000170 -   - */
void (*const vector_93)(void)  @VReserved93  = UNASSIGNED_ISR;  /*0x00000174 -   - */
void (*const vector_94)(void)  @VReserved94  = UNASSIGNED_ISR;  /*0x00000178 -   - */
void (*const vector_95)(void)  @Vkbi1        = UNASSIGNED_ISR;  /*0x0000017C -   - */
void (*const vector_96)(void)  @Vkbi2        = UNASSIGNED_ISR;  /*0x00000180 -   - */
void (*const vector_97)(void)  @Vtod         = UNASSIGNED_ISR;  /*0x00000184 -   - */
void (*const vector_98)(void)  @VReserved98  = UNASSIGNED_ISR;  /*0x00000188 -   - */
void (*const vector_99)(void)  @VReserved99  = UNASSIGNED_ISR;  /*0x0000018C -   - */
void (*const vector_100)(void) @VReserved100 = UNASSIGNED_ISR;  /*0x00000190 -   - */
void (*const vector_101)(void) @VReserved101 = UNASSIGNED_ISR;  /*0x00000194 -   - */
void (*const vector_102)(void) @VReserved102 = UNASSIGNED_ISR;  /*0x00000198 -   - */
void (*const vector_103)(void) @VL7swi       = UNASSIGNED_ISR;  /*0x0000019C -   - */
void (*const vector_104)(void) @VL6swi       = UNASSIGNED_ISR;  /*0x000001A0 -   - */
void (*const vector_105)(void) @VL5swi       = UNASSIGNED_ISR;  /*0x000001A4 -   - */
void (*const vector_106)(void) @VL4swi       = UNASSIGNED_ISR;  /*0x000001A8 -   - */
void (*const vector_107)(void) @VL3swi       = UNASSIGNED_ISR;  /*0x000001AC -   - */
void (*const vector_108)(void) @VL2swi       = UNASSIGNED_ISR;  /*0x000001B0 -   - */
void (*const vector_109)(void) @VL1swi       = UNASSIGNED_ISR;  /*0x000001B4 -   - */
void (*const vector_110)(void) @VReserved110 = UNASSIGNED_ISR;  /*0x000001B8 -   - */
void (*const vector_111)(void) @VReserved111 = UNASSIGNED_ISR;  /*0x000001BC -   - */
void (*const vector_112)(void) @Vftsr1       = UNASSIGNED_ISR;  /*0x000001C0 -   - */
void (*const vector_113)(void) @Vftsr2       = UNASSIGNED_ISR;  /*0x000001C4 -   - */
void (*const vector_114)(void) @VReserved114 = UNASSIGNED_ISR;  /*0x000001C8 -   - */
/*lint -restore Enable MISRA rule (1.1,1.2,11.4) checking. */





/*
** ===================================================================
**     Interrupt handler : isrVtpm1ch0
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVtpm1ch0(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVtpm1ch0 */

/* END MCUinit */

/*
** ###################################################################
**
**     This file was created by Processor Expert 10.0 [05.03]
**     for the Freescale ColdFireV1 series of microcontrollers.
**
** ###################################################################
*/
